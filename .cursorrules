# MCP Tools Template Instructions

You are an expert AI developer, your mission is to develop MCP (Model Context Protocol) tools that can be used by AI agents and applications. These tools are pivotal for enabling AI systems to perform specific actions through the MCP protocol. For example, actions could be: getting current time, listing directories, processing data, calling APIs, file operations, etc. Below are detailed instructions to guide you through the process of creating MCP tools, ensuring they are both functional and align with the MCP framework standards.

## Repository Structure

This is an MCP tools template repository with the following structure:

```
mcp-tools-template/
├── example_tools/
│   ├── function_tools.py    # Recommended function-based tools
│   ├── legacy_tools.py      # Legacy class-based tools (not recommended)
│   └── ...
├── start_mcp.py            # MCP server startup script
├── requirements.txt        # Dependencies
├── Dockerfile             # Container deployment
└── README.md
```

### Key Principles:
- Tools can be organized in directories, like `agent_tools/` (preferred method) or created within the same file (if there are a few tools or it's a test script)
- The MCP server points to tool directories in `start_mcp.py`
- **Function-based tools are preferred** over BaseTool tools (they are deprecated but still supported)
- Simple, flat structure focused on tool functionality

## Tool Creation Approaches

### 1. Function-Based Tools (Recommended)

This is the **preferred method** for creating MCP tools using the `@function_tool` decorator.

#### Structure:
```python
import os
from typing import Optional
from agents import function_tool
from pydantic import BaseModel, Field
from agency_swarm.integrations.mcp_server import run_mcp

# Define Pydantic models for complex arguments
class ToolArgs(BaseModel):
    param1: str = Field(..., description="Description of parameter 1")
    param2: Optional[str] = Field(None, description="Optional parameter 2")

# Define the async function with decorator
@function_tool
async def my_tool_function(args: ToolArgs) -> str:
    """Tool description that explains what this tool does.
    This docstring will be used by the MCP client to understand the tool's purpose.
    """
    # Tool implementation logic here
    try:
        # Your logic using args.param1, args.param2, etc.
        result = f"Tool executed with {args.param1}"
        return result
    except Exception as e:
        return f"Error: {str(e)}"

# For simple tools without arguments
@function_tool
async def simple_tool() -> str:
    """Returns a simple response"""
    return "Simple tool response"
```

#### Best Practices for Function Tools:
- Use **async functions** with the `@function_tool` decorator
- Define **Pydantic models** for complex arguments. You can add field_validators to pydantic models if needed.
- Use **clear, descriptive docstrings** - they become tool descriptions
- **Handle exceptions** gracefully and return error messages as strings
- Return **string responses** that are meaningful to the client
- Use **type hints** for better code clarity

#### Todo List Usage for Tool Development:
**IMPORTANT**: When developing any new MCP tool, ALWAYS create a todo list to track development progress systematically. Use the standard tool development workflow:

1. **Inspect Product Requirements** - Read through PRD.md file to get understanding of the output quality.
2. **Tool Definition** - Define tools purpose, requirements, inputs/outputs. Create a new directory for tools and choose a fitting name for it.
3. **Pydantic Model Design** - Create argument validation schema
4. **Function Implementation** - Write async function with decorator
5. **Error Handling** - Add comprehensive exception management
6. **Documentation** - Write clear docstrings and comments
7. **Testing** - Create test cases and validate functionality
8. **Integration** - Add to MCP server 
9. **Dependencies** - Update requirements.txt as needed
10. **Documentation** - Add usage examples and reference docs

Mark todos as "in_progress" when starting each step and "completed" when finished. This ensures systematic development and helps track progress for complex tools.

### 2. Class-Based Tools (Legacy, Not Recommended)

This approach uses traditional Agency Swarm `BaseTool` classes but is considered legacy.

```python
from pydantic import Field
from agency_swarm import BaseTool

class MyLegacyTool(BaseTool):
    """Description of what this tool does."""
    
    param1: str = Field(..., description="Description of parameter")
    
    def run(self) -> str:
        """Execute the tool logic"""
        return f"Result: {self.param1}"
```

**Note**: While this approach works, function-based tools are preferred for new development.

## MCP Server Configuration

### Server Startup (`start_mcp.py`)

The MCP server is configured to load tools from directories:

```python
import uvicorn
from agency_swarm.integrations.mcp_server import run_mcp

# Point to your tools directory
directory_path = "./example_tools"

# Setup for HTTP transport
def setup_uvicorn_app():
    fastmcp = run_mcp(tools=directory_path, return_app=True)
    app = fastmcp.http_app(stateless_http=True, transport="streamable-http")
    return app

app = setup_uvicorn_app()

if __name__ == "__main__":
    # Preferred way - streamable HTTP
    run_mcp(tools=directory_path, transport="streamable-http", host="0.0.0.0", port=8000)
    # Alternative: stdio transport for direct integration
    # run_mcp(tools=directory_path, transport="stdio")
```

Create app only if user needs a uvicorn deployment, otherwise, prioritize using on-line command:
`run_mcp(tools=...)` if return_app=False (or unset), this command will automatically launch the fastmcp app

Note that tools can be an instance of BaseTool or FunctionTool (i.e. `tools=[FuncTool1, BaseTool2]`) or a path to a directory with tool files (as shown in the example above)

## Testing tools individually
Base tools can be tested easily within the same tool file in the main guard like so:

```
if __name__ == "__main__":
    tool = MyBaseTool(input_param="test)
    print(tool.run())
```

Function tools need a more complex setup. They input needs to be wrapped in the "args" parameter and the function itself should be ran asynchronously:
```
if __name__ == "__main__":
    import asyncio
    import json
    
    async def test_tool():
        # Context should be provided even if it's not part of the original function input. Can be set to None if not used within the tool
        ctx = MasterContext(user_context={"calculations": 1}, thread_manager=None, agents={})
        run_ctx = RunContextWrapper(context=ctx)

        args = ToolInputArgs(input_param="test")
        args_json = {"args": args.model_dump()}
        result = await calculator_tool.on_invoke_tool(run_ctx, json.dumps(args_json))
        print(result)
    
    asyncio.run(test_tool())
```

## Development Guidelines

### 1. Dependencies Management
- All dependencies go in `requirements.txt` in the project root
- Current framework: Agency Swarm with MCP integration
- Import pattern: `from agency_swarm.integrations.mcp_server import run_mcp`

### 2. Tool Organization
- Place tools in logical directories (e.g., `example_tools/`, `file_tools/`, `api_tools/`). Right now, only single path for a directory is supported
- Update `directory_path` in `start_mcp.py` to point to your tools directory

### 3. Environment Variables
- run_mcp internally uses APP_TOKEN variable to set up bearer authentication. If user wants to use auth, create a .env file with APP_TOKEN variable. If not, simply leave it unspecified, in which case the app will disable auth by default

### 4. Error Handling
- Always handle exceptions in tool functions
- Return meaningful error messages as strings

### 5. Testing
- Add test cases in `if __name__ == "__main__":` blocks
- Test tools individually before integrating with the MCP server
- Use the stdio transport for local testing

## Deployment

### Docker Deployment
The repository includes a Dockerfile for containerized deployment:
- Runs on port 8000
- Uses Python 3.12 slim image
- Non-root user for security

### Transport Options
- **streamable-http**, **http** and **sse**: For web-based integration (recommended for production). Default to streamable-http.
- **stdio**: For direct process integration. Only suitable for locally ran servers. Not suitable for web deployments
- **uvicorn**: Alternative HTTP server option

## Tool Examples

### Simple Tool (No Arguments)
```python
@function_tool
async def get_unique_id() -> str:
    """Returns a unique identifier"""
    import uuid
    return f"Unique ID: {uuid.uuid4()}"
```

### Complex Tool (With Arguments)
```python
from typing import Optional
from pydantic import BaseModel, Field

class TimeArgs(BaseModel):
    time_zone: str = Field(..., description="The time zone to get the current time for")
    time_format: Optional[str] = Field(None, description="The format of the time to return")

@function_tool
async def get_current_time(args: TimeArgs) -> str:
    """Returns the current time using datetime library"""
    import datetime
    from zoneinfo import ZoneInfo
    
    try:
        tz = ZoneInfo(args.time_zone)
        current_time = datetime.datetime.now(tz)
        
        if args.time_format:
            formatted_time = current_time.strftime(args.time_format)
        else:
            formatted_time = current_time.strftime("%Y-%m-%d %H:%M:%S %Z")
            
        return f"Current time in {args.time_zone}: {formatted_time}"
    except Exception as e:
        return f"Error getting time for timezone {args.time_zone}: {str(e)}"
```

## Final Notes

**IMPORTANT**: 
- Always use **function-based tools** with `@function_tool` decorator for new development
- **Never output code snippets** in chat - always create or modify actual files
- Focus on **MCP protocol compatibility** rather than agent-specific features
- Keep tools **simple, focused, and reusable**
- Test tools thoroughly before deploying to production
- The MCP server will automatically discover and register tools from the specified directories
